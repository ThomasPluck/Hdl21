"""
This series of tests is made by painstaklingly checking each generated
SPICE file against the correct NgSpice netlist generated by Xschem
to ensure that the generated files have the following properties:
1) Ports are being mapped correctly from physical meaning to SPICE param
2) Primitives and params are passing the correct params to the SPICE file
3) SPICE files aren't breaking design constraints (eg. some resistors have
   no explicit width)
"""

from io import StringIO

import hdl21 as h
import gf180


def test_xtor_netlists():
    """
    Explicitly check xtor netlists to see that nothing
    illegal is being generated and that models are compliant
    with pre-defined PDK behaviour
    """

    @h.generator
    def GenXtor(params: h.MosParams) -> h.Module:
        @h.module
        class SingleXtor:

            a, b, c, d = 4 * h.Signal()
            xtor = h.Mos(params)(d=a, g=b, s=c, b=d)

        return SingleXtor

    for x in gf180.xtors.keys():

        # Relevant params
        p = h.MosParams(model=x[0], tp=x[1], family=x[2], w=30, l=30)

        # Generate & Compile
        mod = h.elaborate(GenXtor(p))
        gf180.compile(mod)

        # Netlist and compare
        s = StringIO()
        h.netlist(mod, dest=s, fmt="spice")
        s = s.getvalue().split("\n")

        assert s[9] == "+ a b c d "  # Correctly maps ports to their places...
        assert s[10] == "+ " + gf180.xtors[x].name + " "  # Has correct PDK name...
        assert (
            s[11] == "+ w='30' l='30' nf='1' As='int((nf+2)/2) * w/nf * 0.18u' pd='2*int((nf+1)/2) * (w/nf + 0.18u)' ps='2*int((nf+2)/2) * (w/nf + 0.18u)' nrd='0.18u / w' nrs='0.18u / w' sa='0' sb='0' sd='0' mult='1' m='1' "
        )  # No weird or illegal parameters...


def test_2_term_res_netlists():
    """
    Explicitly check generic resistor netlists to see that nothing
    illegal is being generated and that models are compliant
    with pre-defined PDK behaviour
    """

    @h.generator
    def GenRes(params: h.PhysicalResistorParams) -> h.Module:
        @h.module
        class SingleRes:

            a, b = 2 * h.Signal()
            genres = h.PhysicalResistor(params)(p=a, n=b)

        return SingleRes

    for x in gf180.ress.keys():

        # This is a hackish way to isolate the two terminal resistors
        if len(gf180.ress[x].port_list) == 2:

            # Relevant params
            p = h.PhysicalResistorParams(model=x, w=10, l=10)

            # Generate & Compile
            mod = h.elaborate(GenRes(p))
            gf180.compile(mod)

            # Netlist and compare
            s = StringIO()
            h.netlist(mod, dest=s, fmt="spice")
            s = s.getvalue().split("\n")

            assert s[9] == "+ a b "  # Correctly maps ports to their places...
            assert s[10] == "+ " + gf180.ress[x].name + " "  # Has correct PDK name...
            assert (
                s[11] == "+ r_width='10' r_length='10' m='1' "
            )  # No weird or illegal parameters...


def test_3_term_res_netlists():
    """
    Explicitly check precision resistor netlists to see that nothing
    illegal is being generated and that models are compliant
    with pre-defined PDK behaviour
    """

    @h.generator
    def GenRes(params: h.PhysicalResistorParams) -> h.Module:
        @h.module
        class SingleRes:

            x, y, z = 3 * h.Signal()
            genres = h.ThreeTerminalResistor(params)(p=x, n=y, b=z)

        return SingleRes

    for x in gf180.ress.keys():

        if len(gf180.ress[x].port_list) == 3:

            # Relevant params
            p = h.PhysicalResistorParams(model=x, w=10, l=10)

            # Generate & Compile
            mod = h.elaborate(GenRes(p))
            gf180.compile(mod)

            # Netlist and compare
            s = StringIO()
            h.netlist(mod, dest=s, fmt="spice")
            s = s.getvalue().split("\n")

            name = gf180.ress[x].name
            assert s[9] == "+ x y z "  # Correctly maps ports to their places
            assert s[10] == "+ " + name + " "  # Has correct PDK name
            assert (
                s[11] == f"+ r_width='10' r_length='10' m='1' "
            )  # No weird or illegal parameters...

def test_diode_netlists():

    """
    Explicitly check diode netlists to see that nothing
    illegal is being generated and that models are compliant
    with pre-defined PDK behaviour
    """

    @h.generator
    def GenDiode(params: h.DiodeParams) -> h.Module:
        @h.module
        class SingleDiode:

            x, y = 2 * h.Signal()
            gendiode = h.Diode(params)(p=x, n=y)

        return SingleDiode

    for x in gf180.diodes.keys():

        # Relevant param
        p = h.DiodeParams(model=x, w=3, l=3)

        # Generate and compile
        mod = h.elaborate(GenDiode(p))
        gf180.compile(mod)

        # Netlist and compare
        s = StringIO()
        h.netlist(mod, dest=s, fmt="spice")
        s = s.getvalue().split("\n")

        assert s[9] == "+ x y "  # Correctly maps ports to their places...
        assert s[10] == "+ " + gf180.diodes[x].name + " "  # Has correct PDK name...
        assert s[11] == "+ area='0.9e1' pj='1.2e1' "  # No weird or illegal parameters...


def test_3T_bjt_netlists():
    @h.generator
    def GenBipolar(params: h.BipolarParams) -> h.Module:
        @h.module
        class SingleBipolar:

            x, y, z = 3 * h.Signal()
            genBipolar = h.Bipolar(params)(c=x, b=y, e=z)

        return SingleBipolar

    for x in gf180.bjts.keys():

        if len(gf180.bjts[x].port_list) == 3:

            # Relevant param
            p = h.BipolarParams(model=x)

            # Generate and compile
            mod = h.elaborate(GenBipolar(p))
            gf180.compile(mod)

            # Netlist and compare
            s = StringIO()
            h.netlist(mod, dest=s, fmt="spice")
            s = s.getvalue().split("\n")

            assert s[9] == "+ x y z "  # Correctly maps ports to their places...
            assert s[10] == "+ " + gf180.bjts[x].name + " "  # Has correct PDK name...
            assert s[11] == "+ m='1' "  # No weird or illegal parameters...

def test_4T_bjt_netlists():

    p = gf180.GF180BipolarParams()
    
    for x in gf180.bjts.keys():

        if len(gf180.bjts[x].port_list) == 4:

            @h.module
            class TestBjt:

                a,d,f,g = 4 * h.Signal()

                exec("genBipolar = gf180.modules."+x)

                BJT = genBipolar(p)(c=a,b=d,e=f,s=g)

            # Generate
            mod = TestBjt

            # Netlist and compare
            s = StringIO()
            h.netlist(mod, dest=s, fmt="spice")
            s = s.getvalue().split("\n")

            assert s[9] == "+ a d f g "  # Correctly maps ports to their places...
            assert s[10] == "+ " + gf180.bjts[x].name + " "  # Has correct PDK name...
            assert s[11] == "+ m='1' "  # N

def test_cap_netlists():
    @h.generator
    def GenMimCap(params: h.PhysicalCapacitorParams) -> h.Module:
        @h.module
        class SingleCap:

            x, y = 2 * h.Signal()
            genCap = h.PhysicalCapacitor(params)(p=x, n=y)

        return SingleCap

    for x in gf180.caps.keys():

        # Relevant params
        p = h.PhysicalCapacitorParams(model=x, w=3, l=3)

        # Generate and compile
        mod = h.elaborate(GenMimCap(p))
        gf180.compile(mod)

        # Netlist and compare
        s = StringIO()
        h.netlist(mod, dest=s, fmt="spice")
        s = s.getvalue().split("\n")

        assert s[9] == "+ x y "  # Correctly maps ports to their places...
        assert s[10] == "+ " + gf180.caps[x].name + " "  # Has correct PDK name...
        assert s[11] == "+ c_width='3' c_length='3' m='1' "  # No weird or illegal parameters...